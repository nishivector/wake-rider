<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Wake Rider — Draft or Die</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  background: #2E5FA3;
  overflow: hidden;
  font-family: 'Courier New', monospace;
}
#c {
  position: fixed; top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
}
#hud-canvas {
  position: fixed; top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 2;
}
/* ── OVERLAYS ── */
.overlay {
  position: fixed; inset: 0;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  z-index: 10;
  pointer-events: all;
}
#startScreen {
  background: transparent;
}
#instrScreen {
  background: rgba(10, 20, 50, 0.92);
}
#endScreen {
  background: rgba(10, 20, 50, 0.92);
}
.hidden { display: none !important; }

/* start screen */
#start-svg-wrap {
  display: flex; flex-direction: column; align-items: center;
  pointer-events: none; user-select: none;
}
#start-subtitle {
  font-size: clamp(14px, 3vw, 22px);
  color: #A8E4FF;
  letter-spacing: 0.35em;
  margin-top: 14px;
  text-shadow: 0 0 18px #A8E4FF;
}
#click-to-begin {
  margin-top: 48px;
  font-size: clamp(13px, 2.5vw, 18px);
  color: #E8C84A;
  letter-spacing: 0.3em;
  text-shadow: 0 0 12px #E8C84A;
  pointer-events: all;
  cursor: pointer;
}
/* instructions */
.instr-title {
  font-size: clamp(18px, 4vw, 28px);
  color: #E8C84A;
  letter-spacing: 0.2em;
  margin-bottom: 28px;
  text-shadow: 0 0 16px #E8C84A;
}
.instr-body {
  color: #A8E4FF;
  font-size: clamp(12px, 2vw, 16px);
  line-height: 2;
  text-align: center;
  max-width: 480px;
  padding: 0 20px;
}
.instr-body b { color: #E8C84A; }
.instr-body .danger { color: #FF4D1C; }
.instr-start {
  margin-top: 36px;
  font-size: clamp(13px, 2.5vw, 18px);
  color: #E8C84A;
  letter-spacing: 0.3em;
  cursor: pointer;
  text-shadow: 0 0 12px #E8C84A;
}
/* results */
.results-title {
  font-size: clamp(22px, 5vw, 36px);
  color: #E8C84A;
  letter-spacing: 0.2em;
  margin-bottom: 24px;
  text-shadow: 0 0 20px #E8C84A;
}
.results-stats {
  color: #A8E4FF;
  font-size: clamp(14px, 2.5vw, 20px);
  line-height: 2.2;
  text-align: center;
}
.results-stats span { color: #E8C84A; }
.results-retry {
  margin-top: 36px;
  font-size: clamp(13px, 2.5vw, 18px);
  color: #E8C84A;
  letter-spacing: 0.3em;
  cursor: pointer;
  text-shadow: 0 0 12px #E8C84A;
}
</style>
<!-- Tone.js FIRST, before importmap -->
<script src="https://cdn.jsdelivr.net/npm/tone@15.1.22/build/Tone.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<canvas id="c"></canvas>
<canvas id="hud-canvas"></canvas>

<!-- START SCREEN -->
<div class="overlay" id="startScreen">
  <div id="start-svg-wrap">
    <svg width="520" height="100" viewBox="0 0 520 100" xmlns="http://www.w3.org/2000/svg" style="max-width:90vw;height:auto">
      <defs>
        <filter id="glow-filter" x="-30%" y="-30%" width="160%" height="160%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur1"/>
          <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur2"/>
          <feMerge><feMergeNode in="blur2"/><feMergeNode in="blur1"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
      </defs>
      <text x="260" y="76" text-anchor="middle"
        font-family="'Courier New', monospace" font-size="72" font-weight="bold"
        fill="#E8C84A" filter="url(#glow-filter)"
        letter-spacing="6">WAKE RIDER</text>
    </svg>
    <div id="start-subtitle">DRAFT OR DIE</div>
  </div>
  <div id="click-to-begin">▶ CLICK TO BEGIN ◀</div>
</div>

<!-- INSTRUCTIONS SCREEN -->
<div class="overlay hidden" id="instrScreen">
  <div class="instr-title">HOW TO RIDE</div>
  <div class="instr-body">
    <b>MOVE MOUSE</b> to steer your wedge<br>
    <b>DRAFT</b> behind enemy ships to borrow their speed<br>
    Stay in the wake — the <span style="color:#A8E4FF">ice-blue lock ring</span> shows your target<br><br>
    <b>Complete 3 laps</b> without losing momentum<br><br>
    <span class="danger">Speed drops to zero = you dissolve</span><br>
    <b>Chain</b> ship-to-ship for a higher speed floor<br><br>
    The enemy formation is your engine.<br>
    <b>When it breaks apart — so do you.</b>
  </div>
  <div class="instr-start" id="instr-go">▶ ENGAGE ENGINES ◀</div>
</div>

<!-- RESULTS SCREEN -->
<div class="overlay hidden" id="endScreen">
  <div class="results-title" id="endTitle">SIGNAL LOST</div>
  <div class="results-stats" id="endStats"></div>
  <div class="results-retry" id="retry-btn">▶ TRY AGAIN ◀</div>
</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// ──────────────────────────────────────────────────────────
// CONSTANTS
// ──────────────────────────────────────────────────────────
const BASE_SPEED     = 140;
const DRAFT_SPEED    = 210;
const MAX_SPEED      = 280;
const FLOOR_SPEED    = 80;
const SPEED_FLOOR_GRACE = 2.5;

// Difficulty per level
const LEVELS = [
  { name:'First Wake',       ships:4, shipSpeed:160, draftRadius:110, bleedRate:28, formation:'oval'      },
  { name:'The Lane',         ships:6, shipSpeed:175, draftRadius:110, bleedRate:32, formation:'dual-oval' },
  { name:'The Split',        ships:7, shipSpeed:190, draftRadius:105, bleedRate:36, formation:'figure8'   },
  { name:'Compression',      ships:8, shipSpeed:205, draftRadius:100, bleedRate:40, formation:'spiral'    },
  { name:'Thread the Needle',ships:10,shipSpeed:220, draftRadius:95,  bleedRate:44, formation:'oblique'   },
];

const TRACK_HALF_W = 20; // world units half-width
const TRACK_HALF_L = 60; // world units half-length (forward)
const LAPS_TO_WIN  = 3;
const CHAIN_GAP    = 1.5; // seconds

// Colors
const COL_GOLD  = 0xE8C84A;
const COL_RED   = 0xFF4D1C;
const COL_ICE   = 0xA8E4FF;
const COL_SHIP  = 0x1A3B6E;
const COL_BG    = 0x2E5FA3;

// ──────────────────────────────────────────────────────────
// STATE
// ──────────────────────────────────────────────────────────
let gameState = 'start'; // start | instructions | playing | results
let currentLevel = 0;

const player = {
  pos: new THREE.Vector3(0, 0, 0),
  speed: BASE_SPEED,
  isDrafting: false,
  draftStrength: 0,
  coronaOpacity: 0,
  draftTimer: 0,   // continuous draft time (for sling)
  floorTimer: 0,   // time below floor
  chainCount: 0,
  chainTimer: 0,
  lastDraftShip: null,
  bestChain: 0,
  bestSpeed: 0,
  lap: 0,
  lapDist: 0,       // accumulated Z travel for lap detection
  startLineZ: 0,    // Z of start line
  lapStartDist: 0,
  dissolved: false,
  targetX: 0,
};

let ships = [];
let wakeTrails = [];  // per-ship trail point arrays
let lockRingMeshes = [];
let wallFlash = { active: false, timer: 0 };
let freezeFrame = { active: false, timer: 0 };
let particles = [];  // formation_split particles

// Cursor tracking
let cursorX = 0;
let cursorNorm = 0.5; // 0..1

// ──────────────────────────────────────────────────────────
// RENDERER + SCENE
// ──────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(COL_BG);
scene.fog = new THREE.Fog(0x1a3a7a, 60, 200);

const aspect = window.innerWidth / window.innerHeight;
const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 2000);
camera.position.set(0, 3.5, -12);
camera.lookAt(0, 0.8, 4);

// Post-processing
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.55, 0.4, 0.72
);
composer.addPass(bloomPass);

const afterimagePass = new AfterimagePass(0.0);
composer.addPass(afterimagePass);

const outputPass = new OutputPass();
composer.addPass(outputPass);

// HUD canvas (DOM, not CanvasTexture)
const hudCanvas = document.getElementById('hud-canvas');
const hud = hudCanvas.getContext('2d');

function resizeAll() {
  const w = window.innerWidth, h = window.innerHeight;
  renderer.setSize(w, h);
  composer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  hudCanvas.width = w;
  hudCanvas.height = h;
}
resizeAll();
window.addEventListener('resize', resizeAll);

// ──────────────────────────────────────────────────────────
// SCENE OBJECTS — PLAYER
// ──────────────────────────────────────────────────────────
function buildPlayerMesh() {
  const g = new THREE.Group();

  // Main wedge: isoceles triangle, wider than long (0.65:1)
  // width=2.6, length=2 -> width/length=1.3, but spec says ratio 0.65:1 (w:l)
  // Re-read: "ratio 0.65:1 — width to length" — so width=0.65, length=1
  // That's NARROWER. Re-read: "wider than long (ratio 0.65:1 — width to length)"
  // Hmm "wider than long" with 0.65:1 width:length means width < length?
  // "wider than long" = width > length. Ratio 0.65 likely means 1:0.65 (length:width)
  // OR the spec means width=1.65 per unit of length=1. Let's go with width=2, length=1.3 to be "wider than long"
  const shape = new THREE.Shape();
  shape.moveTo(0, 1.3);       // leading tip (forward = +Z in world, so model Z is "forward")
  shape.lineTo(-1.0, -0.8);   // rear-left corner
  shape.lineTo(1.0, -0.8);    // rear-right corner
  shape.closePath();
  const geo = new THREE.ShapeGeometry(shape);
  const mat = new THREE.MeshBasicMaterial({ color: COL_GOLD });
  const wedge = new THREE.Mesh(geo, mat);
  wedge.rotation.x = -Math.PI / 2;
  g.add(wedge);

  // Edge glow (line)
  const edgeGeo = new THREE.EdgesGeometry(geo);
  const edgeMat = new THREE.LineBasicMaterial({ color: 0xFFFDE8 });
  const edges = new THREE.LineSegments(edgeGeo, edgeMat);
  edges.rotation.x = -Math.PI / 2;
  g.add(edges);

  // Stabilizer fins
  const finL = buildFin(-1.0, -0.8, -20);
  const finR = buildFin(1.0, -0.8, 20);
  g.add(finL, finR);

  // Corona glow (behind player)
  const coronaGeo = new THREE.PlaneGeometry(2.2, 1.0);
  const coronaMat = new THREE.MeshBasicMaterial({
    color: COL_ICE, transparent: true, opacity: 0, side: THREE.DoubleSide,
    depthWrite: false, blending: THREE.AdditiveBlending
  });
  const corona = new THREE.Mesh(coronaGeo, coronaMat);
  corona.rotation.x = -Math.PI / 2;
  corona.position.z = -0.8;
  corona.position.y = 0.05;
  corona.name = 'corona';
  g.add(corona);

  return g;
}

function buildFin(x, z, angleDeg) {
  const shape = new THREE.Shape();
  shape.moveTo(0, 0);
  shape.lineTo(-0.4, -0.5);
  shape.lineTo(0.4, -0.2);
  shape.closePath();
  const geo = new THREE.ShapeGeometry(shape);
  const mat = new THREE.MeshBasicMaterial({ color: COL_GOLD });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.position.set(x, 0, z);
  mesh.rotation.y = (angleDeg * Math.PI) / 180;
  return mesh;
}

let playerMesh = buildPlayerMesh();
scene.add(playerMesh);

// Dissolve particles (for lose)
let dissolveParts = [];

// ──────────────────────────────────────────────────────────
// FLOOR / OCEAN
// ──────────────────────────────────────────────────────────
const oceanGeo = new THREE.PlaneGeometry(400, 400, 20, 20);
const oceanMat = new THREE.MeshBasicMaterial({ color: 0x1a4080 });
const ocean = new THREE.Mesh(oceanGeo, oceanMat);
ocean.rotation.x = -Math.PI / 2;
ocean.position.y = -0.5;
scene.add(ocean);

// Grid lines on ocean for movement reference
const gridHelper = new THREE.GridHelper(400, 40, 0x2060c0, 0x1a4080);
gridHelper.position.y = -0.48;
scene.add(gridHelper);

// Wall flash overlay (red grid planes)
const wallFlashGeo = new THREE.PlaneGeometry(200, 100, 10, 5);
const wallFlashMat = new THREE.MeshBasicMaterial({
  color: COL_RED, transparent: true, opacity: 0,
  side: THREE.DoubleSide, wireframe: true
});
const wallFlashMesh = new THREE.Mesh(wallFlashGeo, wallFlashMat);
wallFlashMesh.rotation.x = -Math.PI / 2;
wallFlashMesh.position.y = -0.3;
scene.add(wallFlashMesh);

// ──────────────────────────────────────────────────────────
// SHIP GEOMETRY
// ──────────────────────────────────────────────────────────
function buildShipMesh() {
  // Elongated hexagonal prism (cigar-shaped from above)
  const shape = new THREE.Shape();
  const W = 0.7, L = 3.0;
  shape.moveTo(0, L * 0.5);          // front tip
  shape.lineTo(W * 0.6, L * 0.35);
  shape.lineTo(W, 0);
  shape.lineTo(W * 0.6, -L * 0.35);
  shape.lineTo(0, -L * 0.5);         // back tip
  shape.lineTo(-W * 0.6, -L * 0.35);
  shape.lineTo(-W, 0);
  shape.lineTo(-W * 0.6, L * 0.35);
  shape.closePath();

  const geo = new THREE.ShapeGeometry(shape);
  const mat = new THREE.MeshBasicMaterial({ color: COL_SHIP });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;

  // Rim light
  const edgeGeo = new THREE.EdgesGeometry(geo);
  const edgeMat = new THREE.LineBasicMaterial({ color: COL_GOLD });
  const rim = new THREE.LineSegments(edgeGeo, edgeMat);
  rim.rotation.x = -Math.PI / 2;

  const g = new THREE.Group();
  g.add(mesh, rim);
  return g;
}

// ──────────────────────────────────────────────────────────
// BEZIER PATH SYSTEM
// ──────────────────────────────────────────────────────────
function ovalPath(cx, cz, rx, rz, offset = 0) {
  // Returns a function t -> THREE.Vector3 (looping 0..1)
  return function(t) {
    const a = (t + offset) * Math.PI * 2;
    return new THREE.Vector3(cx + Math.cos(a) * rx, 0, cz + Math.sin(a) * rz);
  };
}

function figure8Path(cx, cz, rx, rz, offset = 0) {
  return function(t) {
    const a = (t + offset) * Math.PI * 2;
    return new THREE.Vector3(
      cx + Math.sin(a) * rx,
      0,
      cz + Math.sin(a * 2) * rz * 0.5
    );
  };
}

function spiralPath(cx, cz, baseR, innerR, offset = 0) {
  return function(t) {
    const a = (t + offset) * Math.PI * 2;
    const progress = Math.sin(t * Math.PI * 2) * 0.5 + 0.5; // 0..1
    const r = THREE.MathUtils.lerp(innerR, baseR, progress);
    return new THREE.Vector3(cx + Math.cos(a) * r, 0, cz + Math.sin(a) * r);
  };
}

// ──────────────────────────────────────────────────────────
// LEVEL SETUP
// ──────────────────────────────────────────────────────────
function clearShips() {
  ships.forEach(s => {
    scene.remove(s.mesh);
    s.wakePoints.forEach(wp => scene.remove(wp.mesh));
    if (s.lockRing) scene.remove(s.lockRing);
  });
  ships = [];
  particles.forEach(p => scene.remove(p.mesh));
  particles = [];
}

function buildLockRing() {
  const geo = new THREE.RingGeometry(3.8, 4.2, 48);
  const mat = new THREE.MeshBasicMaterial({
    color: COL_ICE, transparent: true, opacity: 0,
    side: THREE.DoubleSide, depthWrite: false
  });
  const ring = new THREE.Mesh(geo, mat);
  ring.rotation.x = -Math.PI / 2;
  ring.position.y = 0.2;
  scene.add(ring);
  return ring;
}

function spawnShip(pathFn, tOffset, isGhost = false) {
  const mesh = buildShipMesh();
  scene.add(mesh);
  const lockRing = buildLockRing();

  // Wake trail using a simple line system
  const trailMat = new THREE.LineBasicMaterial({
    color: COL_ICE, transparent: true, opacity: 0.7,
    depthWrite: false, blending: THREE.AdditiveBlending
  });

  const ship = {
    mesh,
    pathFn,
    t: tOffset,
    prevPos: new THREE.Vector3(),
    heading: new THREE.Vector3(0, 0, 1),
    isGhost,
    ghostSplit: false,
    splitOffset: 0,
    lockRing,
    lockRingOpacity: 0,
    wakePoints: [],  // {pos, age, mesh}
    trailMat,
    speed: LEVELS[currentLevel].shipSpeed / 400, // dt fraction per frame
  };

  // Warm-start position
  const startPos = pathFn(tOffset);
  mesh.position.copy(startPos);
  ship.prevPos.copy(startPos);
  return ship;
}

function setupLevel(levelIdx) {
  clearShips();
  currentLevel = levelIdx;
  const lv = LEVELS[levelIdx];

  player.pos.set(0, 0, -5);
  player.speed = BASE_SPEED;
  player.isDrafting = false;
  player.draftStrength = 0;
  player.coronaOpacity = 0;
  player.draftTimer = 0;
  player.floorTimer = 0;
  player.chainCount = 0;
  player.chainTimer = 0;
  player.lastDraftShip = null;
  player.lap = 0;
  player.lapDist = 0;
  player.startLineZ = 0;
  player.lapStartDist = 0;
  player.dissolved = false;
  player.bestSpeed = 0;
  player.bestChain = 0;
  playerMesh.visible = true;

  const cx = 0, cz = 10;

  if (lv.formation === 'oval') {
    for (let i = 0; i < lv.ships; i++) {
      ships.push(spawnShip(ovalPath(cx, cz, 14, 28), i / lv.ships));
    }
  } else if (lv.formation === 'dual-oval') {
    const half = Math.floor(lv.ships / 2);
    for (let i = 0; i < half; i++) {
      ships.push(spawnShip(ovalPath(cx - 14, cz, 8, 24), i / half));
    }
    for (let i = 0; i < lv.ships - half; i++) {
      ships.push(spawnShip(ovalPath(cx + 14, cz, 8, 24), i / (lv.ships - half)));
    }
  } else if (lv.formation === 'figure8') {
    for (let i = 0; i < 6; i++) {
      ships.push(spawnShip(figure8Path(cx, cz, 16, 26), i / 6));
    }
    // Ghost pacer
    const ghost = spawnShip(figure8Path(cx, cz, 16, 26), 0, true);
    ships.push(ghost);
  } else if (lv.formation === 'spiral') {
    for (let i = 0; i < lv.ships; i++) {
      ships.push(spawnShip(spiralPath(cx, cz, 20, 8), i / lv.ships));
    }
  } else { // oblique
    for (let i = 0; i < lv.ships; i++) {
      const angle = (i / lv.ships) * Math.PI * 2;
      ships.push(spawnShip(ovalPath(
        cx + Math.sin(angle) * 5, cz, 14 + i * 0.8, 22 + i * 1.2
      ), i / lv.ships));
    }
  }
}

// ──────────────────────────────────────────────────────────
// AUDIO ENGINE
// ──────────────────────────────────────────────────────────
let audioReady = false;
let musicState = 'OUT_OF_DRAFT';
let inDraftTransition = false;

// Music nodes
let bass, bassFilter, bassGain;
let bassHigh, bassHighFilter, bassHighGain;
let pad, padGain;
let hihat, hihatGain;
let kick;
let shimmer;
let musicLoop;
let hihatLoop;
let kickLoop;

// SFX nodes
let sfxDraftEnter;
let sfxDraftBreakMembrane, sfxDraftBreakSynth;
let sfxSpeedBleed, sfxSpeedBleedLFO, sfxSpeedBleedActive = false;
let sfxChainLock;
let sfxWallHit;
let sfxFormationSplit;

function initAudio() {
  if (audioReady) return;
  audioReady = true;

  try {
    Tone.start();

    // ── MUSIC ──
    const BPM = 138;
    Tone.getTransport().bpm.value = BPM;

    // Sawtooth bass
    bassFilter = new Tone.Filter(400, 'lowpass');
    bassGain = new Tone.Volume(-6);
    bass = new Tone.Synth({
      oscillator: { type: 'sawtooth' },
      envelope: { attack: 0.01, decay: 0.1, sustain: 0.9, release: 0.1 }
    }).connect(bassFilter);
    bassFilter.connect(bassGain).toDestination();

    // Second bass layer (in-draft only)
    bassHighFilter = new Tone.Filter(5000, 'lowpass');
    bassHighGain = new Tone.Volume(-12);
    bassHigh = new Tone.Synth({
      oscillator: { type: 'sawtooth' },
      envelope: { attack: 0.05, decay: 0.1, sustain: 0.9, release: 0.1 }
    }).connect(bassHighFilter);
    bassHighFilter.connect(bassHighGain).toDestination();
    bassHighGain.mute = true;

    // Pad
    padGain = new Tone.Volume(-8);
    pad = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'sine' },
      envelope: { attack: 0.8, decay: 0.5, sustain: 0.8, release: 2.0 }
    }).connect(padGain).toDestination();

    // Hi-hat
    hihatGain = new Tone.Volume(-16);
    hihat = new Tone.MetalSynth({
      frequency: 400, envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
      harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
    }).connect(hihatGain).toDestination();

    // Kick
    kick = new Tone.MembraneSynth({
      pitchDecay: 0.07, octaves: 5,
      envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }
    }).toDestination();

    // Shimmer (for in-draft state)
    shimmer = new Tone.AutoFilter({
      frequency: 4, depth: 0.4, waveType: 'sine', octaves: 0.5
    }).toDestination();
    shimmer.stop();

    // Music sequencing
    const beatDur = 60 / BPM; // seconds per beat
    const step = beatDur / 4;  // 16th note

    // F minor: F Ab Cb (Eb)
    const bassNotes = ['F1', 'F1', 'Eb1', 'F1', 'F1', 'Ab1', 'Eb1', 'F1'];
    let bassBeat = 0;
    musicLoop = new Tone.Loop(time => {
      const note = bassNotes[bassBeat % bassNotes.length];
      bass.triggerAttackRelease(note, '8n', time);
      if (!bassHighGain.mute) {
        // Octave up
        const highNote = note.replace(/(\d)/, n => String(parseInt(n) + 1));
        bassHigh.triggerAttackRelease(highNote, '8n', time);
      }
      bassBeat++;
    }, '8n');
    musicLoop.start(0);

    let hihatBeat = 0;
    hihatLoop = new Tone.Loop(time => {
      hihat.triggerAttackRelease('16n', time);
      hihatBeat++;
    }, '16n');
    hihatLoop.start(0);

    let kickBeat = 0;
    kickLoop = new Tone.Loop(time => {
      if (kickBeat % 2 === 0) kick.triggerAttackRelease('C1', '8n', time);
      kickBeat++;
    }, '4n');
    kickLoop.start(0);

    // Pad chord (F minor: F3 Ab3 C4)
    const padInterval = new Tone.Loop(time => {
      pad.triggerAttackRelease(['F3', 'Ab3', 'C4'], '2n', time);
    }, '1m');
    padInterval.start(0);

    Tone.getTransport().start();

    // ── SFX ──
    // 1. draft_enter
    sfxDraftEnter = new Tone.Synth({
      oscillator: { type: 'sine' },
      envelope: { attack: 0.05, decay: 0.15, sustain: 0.6, release: 0.2 }
    }).toDestination();
    sfxDraftEnter.volume.value = -8;

    // 2. draft_break
    sfxDraftBreakMembrane = new Tone.MembraneSynth({
      pitchDecay: 0.04, octaves: 4,
      envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 }
    }).toDestination();
    sfxDraftBreakMembrane.volume.value = -4;

    sfxDraftBreakSynth = new Tone.Synth({
      oscillator: { type: 'sine' },
      envelope: { attack: 0.01, decay: 0.25, sustain: 0.3, release: 0.3 }
    }).toDestination();
    sfxDraftBreakSynth.volume.value = -4;

    // 3. speed_bleed
    const bleedSynth = new Tone.Synth({
      oscillator: { type: 'sine' },
      envelope: { attack: 0.1, decay: 0.5, sustain: 0.8, release: 0.3 }
    }).toDestination();
    bleedSynth.frequency.value = 60;
    bleedSynth.volume.value = -18;
    sfxSpeedBleed = bleedSynth;
    sfxSpeedBleedLFO = new Tone.LFO({ frequency: 1.4, type: 'sine', min: -32, max: -18 });
    sfxSpeedBleedLFO.connect(bleedSynth.volume);
    sfxSpeedBleedLFO.start();

    // 4. chain_lock
    sfxChainLock = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 }
    }).toDestination();
    sfxChainLock.volume.value = -10;

    // 5. wall_hit
    sfxWallHit = new Tone.MetalSynth({
      frequency: 40,
      envelope: { attack: 0.001, decay: 0.4, release: 0.2 },
      harmonicity: 3.1, modulationIndex: 12, resonance: 3200, octaves: 1.2
    }).toDestination();
    sfxWallHit.volume.value = -2;

    // 6. formation_split — created on demand

  } catch (e) {
    // audio init silently fails — game still runs
  }
}

function playSFX_draftEnter() {
  if (!audioReady || !sfxDraftEnter) return;
  try {
    sfxDraftEnter.triggerAttackRelease(180, 0.4);
    sfxDraftEnter.frequency.rampTo(340, 0.4);
  } catch(e) {}
}

function playSFX_draftBreak() {
  if (!audioReady || !sfxDraftBreakMembrane) return;
  try {
    sfxDraftBreakMembrane.triggerAttackRelease(200, 0.05);
    setTimeout(() => {
      if (!sfxDraftBreakSynth) return;
      sfxDraftBreakSynth.triggerAttackRelease(280, 0.45);
      sfxDraftBreakSynth.frequency.rampTo(90, 0.45);
    }, 60);
  } catch(e) {}
}

function playSFX_chainLock() {
  if (!audioReady || !sfxChainLock) return;
  try {
    sfxChainLock.triggerAttackRelease(880, 0.3);
    setTimeout(() => sfxChainLock && sfxChainLock.triggerAttackRelease(1320, 0.3), 150);
  } catch(e) {}
}

function playSFX_wallHit() {
  if (!audioReady || !sfxWallHit) return;
  try { sfxWallHit.triggerAttackRelease('40n'); } catch(e) {}
}

function playSFX_formationSplit() {
  if (!audioReady) return;
  try {
    // 5 voices at unison 220Hz, panning out
    const panners = [-1, -0.5, 0, 0.5, 1].map(p => new Tone.Panner(p).toDestination());
    const synths = [180, 210, 220, 245, 270].map((freq, i) => {
      const s = new Tone.Synth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.05, decay: 1.2, sustain: 0.5, release: 1.2 }
      }).connect(panners[i]);
      s.volume.value = -12;
      s.triggerAttackRelease(220, 2.0);
      // Glide to target frequency
      s.frequency.rampTo(freq, 1.5);
      return s;
    });

    // Silence music briefly after 0.3s
    if (padGain) {
      setTimeout(() => {
        if (padGain) padGain.volume.rampTo(-40, 0.1);
        setTimeout(() => { if (padGain) padGain.volume.rampTo(-8, 0.5); }, 400);
      }, 300);
    }

    setTimeout(() => {
      synths.forEach(s => { try { s.dispose(); } catch(e) {} });
      panners.forEach(p => { try { p.dispose(); } catch(e) {} });
    }, 4000);
  } catch(e) {}
}

function setMusicState(newState) {
  if (!audioReady || musicState === newState) return;
  musicState = newState;
  try {
    if (newState === 'IN_DRAFT') {
      bassFilter && bassFilter.frequency.rampTo(2800, 0.8);
      bassHighGain && (bassHighGain.mute = false);
      padGain && padGain.volume.rampTo(-2, 0.8);
      hihatGain && hihatGain.volume.rampTo(-10, 0.8);
    } else {
      bassFilter && bassFilter.frequency.rampTo(400, 0.3);
      bassHighGain && (bassHighGain.mute = true);
      padGain && padGain.volume.rampTo(-8, 0.8);
      hihatGain && hihatGain.volume.rampTo(-16, 0.8);
    }
  } catch(e) {}
}

// ──────────────────────────────────────────────────────────
// DRAFT COMPUTATION
// ──────────────────────────────────────────────────────────
function computeDraftStrength(playerWorldPos, ship) {
  const lv = LEVELS[currentLevel];
  const draftRadius = lv.draftRadius / 10; // convert px to world units (rough)

  const delta = new THREE.Vector3().subVectors(playerWorldPos, ship.mesh.position);
  const dist = delta.length();
  if (dist > draftRadius) return 0;

  // Check rear arc (180° behind ship heading)
  const heading = ship.heading; // normalized
  const toPlayer = delta.clone().normalize();
  const dot = toPlayer.dot(heading); // dot with forward heading
  // Behind = negative dot (player is in the -heading direction)
  // rear arc 180° = dot < 0 (any angle behind the ship)
  // Actually we want dot with reverse heading to be > 0 means player is behind
  if (dot > 0.1) return 0; // player is in front of ship

  // Angle from heading axis (lateral falloff)
  const angle = Math.acos(Math.max(-1, Math.min(1, -dot))); // 0 = directly behind
  const lateralFactor = Math.pow(Math.cos(angle), 2);

  // Depth: teardrop
  const NEAR = draftRadius * 0.36; // 40px out of 110px
  const MID  = draftRadius * 0.72; // 80px
  let depthFactor;
  if (dist <= NEAR) {
    depthFactor = 1.0;
  } else if (dist <= MID) {
    depthFactor = THREE.MathUtils.lerp(1.0, 0.6, (dist - NEAR) / (MID - NEAR));
  } else {
    depthFactor = THREE.MathUtils.lerp(0.6, 0.0, (dist - MID) / (draftRadius - MID));
  }

  return lateralFactor * depthFactor;
}

function computeApproachRadius(playerWorldPos, ship) {
  const lv = LEVELS[currentLevel];
  const approachRadius = (lv.draftRadius + 20) / 10;
  const delta = new THREE.Vector3().subVectors(playerWorldPos, ship.mesh.position);
  return delta.length() < approachRadius;
}

// ──────────────────────────────────────────────────────────
// WAKE TRAIL SYSTEM
// ──────────────────────────────────────────────────────────
const TRAIL_LIFETIME = 1.2;
const TRAIL_INTERVAL = 0.05;
let trailTimer = 0;

function updateWakeTrail(ship, dt) {
  // Add new point
  trailTimer += dt;
  if (trailTimer > TRAIL_INTERVAL) {
    // Add wake point
    const pt = {
      pos: ship.mesh.position.clone(),
      age: 0,
      leftPos: new THREE.Vector3(
        ship.mesh.position.x - ship.heading.z * 0.6,
        ship.mesh.position.y,
        ship.mesh.position.z + ship.heading.x * 0.6
      ),
      rightPos: new THREE.Vector3(
        ship.mesh.position.x + ship.heading.z * 0.6,
        ship.mesh.position.y,
        ship.mesh.position.z - ship.heading.x * 0.6
      ),
    };
    ship.wakePoints.push(pt);
  }

  // Age points
  ship.wakePoints.forEach(pt => { pt.age += dt; });

  // Remove old points
  ship.wakePoints = ship.wakePoints.filter(pt => pt.age < TRAIL_LIFETIME);
}

function renderWakeTrail(ship) {
  if (ship.wakePoints.length < 2) return;

  // Build line positions from wake points
  const pts = ship.wakePoints;
  const positions = [];

  for (let i = 0; i < pts.length; i++) {
    const alpha = 1 - (pts[i].age / TRAIL_LIFETIME);
    const spread = (pts[i].age / TRAIL_LIFETIME) * 1.5; // chevron spread

    positions.push(
      pts[i].pos.x - ship.heading.z * spread, pts[i].pos.y + 0.1, pts[i].pos.z + ship.heading.x * spread,
      pts[i].pos.x + ship.heading.z * spread, pts[i].pos.y + 0.1, pts[i].pos.z - ship.heading.x * spread,
    );
  }

  if (!ship.wakeLineMesh) {
    const geo = new THREE.BufferGeometry();
    const arr = new Float32Array(positions.length);
    geo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
    const mat = new THREE.LineSegments(geo, new THREE.LineBasicMaterial({
      color: COL_ICE, transparent: true, opacity: 0.6,
      depthWrite: false, blending: THREE.AdditiveBlending
    }));
    ship.wakeLineMesh = mat;
    scene.add(mat);
  } else {
    const geo = ship.wakeLineMesh.geometry;
    const buf = geo.attributes.position;
    if (buf.count * 3 !== positions.length) {
      const arr = new Float32Array(positions.length);
      geo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
    }
    const arr2 = geo.attributes.position.array;
    for (let i = 0; i < positions.length; i++) arr2[i] = positions[i];
    geo.attributes.position.needsUpdate = true;
    geo.setDrawRange(0, positions.length / 3);
    geo.computeBoundingSphere();
  }
}

// ──────────────────────────────────────────────────────────
// PARTICLE SYSTEM (Formation split)
// ──────────────────────────────────────────────────────────
function spawnSplitParticles(pos) {
  for (let i = 0; i < 48; i++) {
    const angle = (i / 48) * Math.PI * 2;
    const speed = 60 / 60; // 60 u/s converted
    const geo = new THREE.SphereGeometry(0.12, 4, 4);
    const mat = new THREE.MeshBasicMaterial({
      color: COL_ICE, transparent: true, opacity: 1,
      blending: THREE.AdditiveBlending
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    particles.push({
      mesh, mat,
      vx: Math.cos(angle) * speed,
      vz: Math.sin(angle) * speed,
      age: 0,
      life: 0.4
    });
  }
}

// ──────────────────────────────────────────────────────────
// LAP SYSTEM
// ──────────────────────────────────────────────────────────
// We track lap by cumulative distance: every ~200 world units = 1 lap
const LAP_DISTANCE = 200;
let lapCompleteFlash = 0;
let formationSplitFired = false;

function checkLap() {
  if (gameState !== 'playing') return;
  const newDist = player.lapDist + (player.speed / 60); // approximation
  player.lapDist = newDist;

  const lapsNow = Math.floor(player.lapDist / LAP_DISTANCE);
  if (lapsNow > player.lap) {
    player.lap = lapsNow;
    lapCompleteFlash = 1.0;

    if (player.lap >= LAPS_TO_WIN) {
      setTimeout(() => endGame(true), 80); // freeze frame
    } else if (currentLevel === 2 && player.lap === 2 && !formationSplitFired) {
      // THE MOMENT — Level 3, lap 3 start
      formationSplitFired = true;
      triggerFormationSplit();
    }
  }
}

// ──────────────────────────────────────────────────────────
// THE MOMENT
// ──────────────────────────────────────────────────────────
let ghostPacerSplitActive = false;
let ghostPacerSplitTimer = 0;
let ghostCopies = [];

function triggerFormationSplit() {
  const ghost = ships.find(s => s.isGhost);
  if (!ghost) return;

  ghost.ghostSplit = true;
  ghostPacerSplitActive = true;
  ghostPacerSplitTimer = 8.0;

  // Shimmer effect
  ghost.shimmerTimer = 0.7;

  // Particles
  spawnSplitParticles(ghost.mesh.position);

  // SFX
  playSFX_formationSplit();

  // Create 5 diverging copies
  const anglesDiv = [24, 12, 0, -12, -24].map(a => a * Math.PI / 180);
  ghostCopies = anglesDiv.map(angleOff => {
    const copy = spawnShip(ghost.pathFn, ghost.t, true);
    copy.splitAngleOff = angleOff;
    copy.isCopy = true;
    scene.add(copy.mesh);
    ships.push(copy);
    return copy;
  });
}

// ──────────────────────────────────────────────────────────
// DISSOLVE EFFECT
// ──────────────────────────────────────────────────────────
function startDissolve() {
  player.dissolved = true;
  playerMesh.visible = false;

  for (let i = 0; i < 40; i++) {
    const geo = new THREE.TetrahedronGeometry(0.1 + Math.random() * 0.3);
    const mat = new THREE.MeshBasicMaterial({ color: COL_GOLD, transparent: true, opacity: 1 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(player.pos);
    scene.add(mesh);
    const angle = Math.random() * Math.PI * 2;
    const pitch = (Math.random() - 0.5) * 1.5;
    const speed = 1 + Math.random() * 3;
    dissolveParts.push({
      mesh, mat,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(pitch) * speed * 0.5,
      vz: Math.sin(angle) * speed,
      age: 0,
      life: 0.6 + Math.random() * 0.3
    });
  }
}

// ──────────────────────────────────────────────────────────
// INPUT
// ──────────────────────────────────────────────────────────
document.addEventListener('pointermove', e => {
  const rect = canvas.getBoundingClientRect();
  cursorNorm = (e.clientX - rect.left) / rect.width;
  cursorX = e.clientX;
});

// ──────────────────────────────────────────────────────────
// HUD RENDERING
// ──────────────────────────────────────────────────────────
function drawHUD() {
  const w = hudCanvas.width, h = hudCanvas.height;
  hud.clearRect(0, 0, w, h);

  if (gameState !== 'playing') return;

  const lv = LEVELS[currentLevel];
  const floorSpeedWithChain = Math.min(160, FLOOR_SPEED + player.chainCount * 20);
  const speedFrac = (player.speed - FLOOR_SPEED) / (MAX_SPEED - FLOOR_SPEED);
  const floorFrac = (floorSpeedWithChain - FLOOR_SPEED) / (MAX_SPEED - FLOOR_SPEED);

  // Speed bar (left side, vertical)
  const barX = 28, barY = h * 0.2, barH = h * 0.6, barW = 16;
  hud.fillStyle = 'rgba(10,20,50,0.5)';
  hud.fillRect(barX - 2, barY - 2, barW + 4, barH + 4);

  // Bar fill
  const fillH = barH * Math.max(0, Math.min(1, speedFrac));
  const speedColor = player.speed < floorSpeedWithChain + 20 ? '#FF4D1C' : '#E8C84A';
  hud.fillStyle = speedColor;
  hud.fillRect(barX, barY + barH - fillH, barW, fillH);

  // Floor line
  const floorY = barY + barH * (1 - floorFrac);
  hud.strokeStyle = '#FF4D1C';
  hud.lineWidth = 2;
  hud.beginPath();
  hud.moveTo(barX - 4, floorY);
  hud.lineTo(barX + barW + 4, floorY);
  hud.stroke();

  // Speed number
  hud.fillStyle = '#E8C84A';
  hud.font = `bold ${Math.round(h * 0.022)}px 'Courier New', monospace`;
  hud.textAlign = 'left';
  hud.fillText(Math.round(player.speed), barX, barY + barH + 20);

  // Chain count (upper left)
  const chainSize = Math.round(h * 0.05);
  hud.font = `bold ${chainSize}px 'Courier New', monospace`;
  hud.textAlign = 'left';
  hud.fillStyle = '#E8C84A';
  hud.fillText(`×${player.chainCount}`, 52, 54);
  hud.font = `${Math.round(h * 0.018)}px 'Courier New', monospace`;
  hud.fillStyle = 'rgba(168,228,255,0.7)';
  hud.fillText('CHAIN', 52, 72);

  // Lap counter (upper center)
  hud.font = `bold ${Math.round(h * 0.028)}px 'Courier New', monospace`;
  hud.textAlign = 'center';
  hud.fillStyle = lapCompleteFlash > 0 ? `rgba(232,200,74,${lapCompleteFlash})` : '#A8E4FF';
  hud.fillText(`LAP ${player.lap + 1} / ${LAPS_TO_WIN}`, w / 2, 42);

  // Draft indicator
  if (player.isDrafting) {
    hud.textAlign = 'center';
    hud.font = `${Math.round(h * 0.02)}px 'Courier New', monospace`;
    hud.fillStyle = '#A8E4FF';
    hud.fillText('◈ DRAFTING', w / 2, h - 24);
  } else if (player.speed < floorSpeedWithChain + 30) {
    // Danger pulse
    const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.008);
    hud.textAlign = 'center';
    hud.font = `bold ${Math.round(h * 0.022)}px 'Courier New', monospace`;
    hud.fillStyle = `rgba(255,77,28,${pulse})`;
    hud.fillText('⚠ FIND DRAFT', w / 2, h - 24);
  }

  // Wall flash
  if (wallFlash.active) {
    const alpha = wallFlash.timer / 0.4;
    hud.strokeStyle = `rgba(255,77,28,${alpha * 0.6})`;
    hud.lineWidth = 8;
    hud.strokeRect(0, 0, w, h);
  }

  // Lap flash
  if (lapCompleteFlash > 0) {
    hud.fillStyle = `rgba(232,200,74,${lapCompleteFlash * 0.15})`;
    hud.fillRect(0, 0, w, h);
    lapCompleteFlash = Math.max(0, lapCompleteFlash - 0.03);
  }
}

// ──────────────────────────────────────────────────────────
// START SCREEN ANIMATION (Three.js)
// ──────────────────────────────────────────────────────────
let startShips = [];
let startPlayerWedge;
let lockRingTimer = 0;
let lockRingAlpha = 0;
let lockRingVisible = false;
let lockRingTarget = null;

function buildStartScreen() {
  // 3 ships orbiting center in triangular formation
  startShips = [];
  for (let i = 0; i < 3; i++) {
    const mesh = buildShipMesh();
    scene.add(mesh);
    startShips.push({ mesh, t: i / 3, wakePoints: [], heading: new THREE.Vector3(0,0,1) });
  }

  // Player wedge parked at bottom center
  // (re-use playerMesh)
  player.pos.set(0, 0, -10);
  playerMesh.position.copy(player.pos);

  // Camera for start screen
  camera.position.set(0, 8, -20);
  camera.lookAt(0, 0, 0);
}

function updateStartScreen(dt) {
  const t = Date.now() * 0.001;

  // Orbit ships
  startShips.forEach((s, i) => {
    const a = (t * 0.3 + i * Math.PI * 2 / 3);
    const px = Math.cos(a) * 8;
    const pz = Math.sin(a) * 8 + 5;
    const prev = s.mesh.position.clone();
    s.mesh.position.set(px, 0, pz);
    const dv = new THREE.Vector3().subVectors(s.mesh.position, prev);
    if (dv.length() > 0.001) s.heading.copy(dv.normalize());
    s.mesh.rotation.y = Math.atan2(s.heading.x, s.heading.z);

    // Wake trail
    s.wakePoints.push({ pos: s.mesh.position.clone(), age: 0 });
    s.wakePoints.forEach(p => p.age += dt);
    s.wakePoints = s.wakePoints.filter(p => p.age < 1.5);
    renderWakeTrail(s);
  });

  // Corona pulse on player
  const corona = playerMesh.getObjectByName('corona');
  if (corona) {
    const pulse = 0.3 + 0.4 * (0.5 + 0.5 * Math.sin(t * Math.PI * 2 * 2));
    corona.material.opacity = pulse;
  }

  // Lock ring every 4 seconds
  lockRingTimer += dt;
  if (lockRingTimer > 4.0 && !lockRingVisible) {
    lockRingVisible = true;
    lockRingTimer = 0;
    lockRingTarget = startShips[0];
  }
  if (lockRingVisible && lockRingTarget) {
    const phase = lockRingTimer;
    if (phase < 0.3) lockRingAlpha = phase / 0.3;
    else if (phase < 0.8) lockRingAlpha = 1;
    else if (phase < 1.1) lockRingAlpha = 1 - (phase - 0.8) / 0.3;
    else { lockRingAlpha = 0; lockRingVisible = false; }

    if (lockRingTarget.lockRing) {
      lockRingTarget.lockRing = lockRingTarget.lockRing;
    }
  }

  // Flash click-to-begin
  const ctb = document.getElementById('click-to-begin');
  if (ctb) {
    const blink = Math.sin(t * Math.PI / 0.7) > 0;
    ctb.style.opacity = blink ? '1' : '0.2';
  }

  // Camera floats gently
  camera.position.set(0, 8 + Math.sin(t * 0.4) * 0.3, -22 + Math.sin(t * 0.3) * 1);
  camera.lookAt(0, 0, 2);
}

// ──────────────────────────────────────────────────────────
// MAIN GAME UPDATE
// ──────────────────────────────────────────────────────────
let lastTime = null;
let cameraZSmooth = -12;

function update(dt) {
  if (freezeFrame.active) {
    freezeFrame.timer -= dt;
    if (freezeFrame.timer <= 0) freezeFrame.active = false;
    return;
  }

  const lv = LEVELS[currentLevel];

  // ── PLAYER STEERING ──
  const targetWorldX = (cursorNorm * 2 - 1) * TRACK_HALF_W * 0.9;
  player.pos.x = THREE.MathUtils.lerp(player.pos.x, targetWorldX * 0.6, 0.12);

  // ── PLAYER SPEED ──
  const floorSpeedNow = Math.min(160, FLOOR_SPEED + player.chainCount * 20);

  // Find best draft
  let bestDraft = 0;
  let bestDraftShip = null;
  for (const s of ships) {
    if (s.isCopy && !ghostPacerSplitActive) continue;
    const ds = computeDraftStrength(player.pos, s);
    if (ds > bestDraft) { bestDraft = ds; bestDraftShip = s; }
  }

  player.draftStrength = THREE.MathUtils.lerp(player.draftStrength, bestDraft, 0.15);
  const wasInDraft = player.isDrafting;
  player.isDrafting = player.draftStrength > 0.1;

  // Draft state transitions
  if (!wasInDraft && player.isDrafting) {
    // Entered draft
    const wasChaining = player.chainTimer > 0 && player.chainTimer < CHAIN_GAP;
    if (wasChaining && player.lastDraftShip && player.lastDraftShip !== bestDraftShip) {
      player.chainCount++;
      if (player.chainCount > player.bestChain) player.bestChain = player.chainCount;
      playSFX_chainLock();
    } else if (!wasChaining) {
      player.chainCount = 0;
    }
    player.lastDraftShip = bestDraftShip;
    player.chainTimer = 0;
    playSFX_draftEnter();
    setMusicState('IN_DRAFT');
  } else if (wasInDraft && !player.isDrafting) {
    // Left draft
    player.lastDraftShip = bestDraftShip;
    player.chainTimer = 0;
    playSFX_draftBreak();
    setMusicState('OUT_OF_DRAFT');
  }

  if (!player.isDrafting) {
    player.chainTimer += dt;
    if (player.chainTimer > CHAIN_GAP) player.chainCount = 0;
  }

  // Speed model
  if (player.isDrafting) {
    const targetSpeed = player.draftStrength >= 0.8 ? DRAFT_SPEED :
                        THREE.MathUtils.lerp(BASE_SPEED, DRAFT_SPEED, player.draftStrength);
    player.speed = THREE.MathUtils.lerp(player.speed, targetSpeed, 0.04);

    // Sling: after 2s drafting, ramp to MAX_SPEED
    player.draftTimer += dt;
    if (player.draftTimer > 2.0) {
      const slingProgress = Math.min(1, (player.draftTimer - 2.0) / 2.0);
      const slingTarget = THREE.MathUtils.lerp(DRAFT_SPEED, MAX_SPEED, slingProgress);
      player.speed = Math.max(player.speed, slingTarget);
    }
  } else {
    player.draftTimer = 0;
    // Bleed: squared — faster means faster loss
    const bleedFactor = (player.speed / MAX_SPEED);
    player.speed -= lv.bleedRate * bleedFactor * bleedFactor * dt;
    player.speed = Math.max(floorSpeedNow - 5, player.speed);
  }

  // Speed floor tracking
  if (player.speed <= floorSpeedNow && !player.dissolved) {
    player.floorTimer += dt;
    if (player.floorTimer > SPEED_FLOOR_GRACE) {
      startDissolve();
      setTimeout(() => endGame(false), 700);
    }
  } else {
    player.floorTimer = Math.max(0, player.floorTimer - dt * 2);
  }

  if (player.speed > player.bestSpeed) player.bestSpeed = player.speed;

  // ── PLAYER POSITION ──
  // Player moves forward at their speed
  player.pos.z += player.speed * dt * 0.08; // scale to world units

  // Wall boundary check
  if (Math.abs(player.pos.x) > TRACK_HALF_W) {
    player.pos.x = Math.sign(player.pos.x) * TRACK_HALF_W;
    player.speed = Math.max(floorSpeedNow, player.speed * 0.5);
    wallFlash.active = true;
    wallFlash.timer = 0.4;
    player.chainCount = 0;
    playSFX_wallHit();

    // Wall flash mesh
    wallFlashMesh.material.opacity = 0.7;
    wallFlashMesh.visible = true;
  }

  if (wallFlash.active) {
    wallFlash.timer -= dt;
    const alpha = wallFlash.timer / 0.4;
    wallFlashMesh.material.opacity = alpha * 0.7;
    if (wallFlash.timer <= 0) {
      wallFlash.active = false;
      wallFlashMesh.material.opacity = 0;
    }
  }

  // ── LAP TRACKING ──
  checkLap();

  // ── PLAYER MESH ──
  playerMesh.position.copy(player.pos);
  // Orient player toward direction of movement (always facing forward)
  // Slight lean based on lateral velocity
  const leanAngle = -(player.pos.x - (player.pos.x * 0.98)) * 0.1;

  // Corona opacity
  const targetCoronaOpacity = player.isDrafting ? (0.6 + 0.4 * Math.sin(Date.now() * 0.001 * Math.PI * 2 * 2)) : 0;
  const coronaLerpSpeed = player.isDrafting ? 1.0 / 0.15 : 1.0 / 0.3;
  player.coronaOpacity = THREE.MathUtils.lerp(player.coronaOpacity, targetCoronaOpacity, dt * coronaLerpSpeed);
  const corona = playerMesh.getObjectByName('corona');
  if (corona) corona.material.opacity = Math.max(0, player.coronaOpacity);

  // ── AFTERIMAGE ──
  const spd = player.speed;
  let damp = 0;
  if (spd > 220) damp = 0.82;
  else if (spd > 160) damp = THREE.MathUtils.lerp(0, 0.82, (spd - 160) / 60);
  afterimagePass.uniforms['damp'].value = damp;

  // ── SHIPS UPDATE ──
  const shipSpeedPerSec = lv.shipSpeed;
  ships.forEach(s => {
    if (s.isCopy && !ghostPacerSplitActive) {
      s.mesh.visible = false;
      return;
    }

    const prevPos = s.mesh.position.clone();

    // Advance along path
    s.t += (shipSpeedPerSec / 1000) * dt;
    if (s.t > 1) s.t -= 1;

    let newPos;
    if (s.ghostSplit && s.splitOffset !== undefined) {
      // Diverge from path with angle offset
      const basePos = s.pathFn(s.t);
      const angleOff = s.splitOffset || 0;
      const progress = Math.min(1, ghostPacerSplitTimer < 0 ? 1 : (8 - ghostPacerSplitTimer) / 8);
      const spread = progress * 8;
      newPos = new THREE.Vector3(
        basePos.x + Math.cos(angleOff) * spread,
        0,
        basePos.z + Math.sin(angleOff) * spread
      );
    } else {
      newPos = s.pathFn(s.t);
    }

    s.mesh.position.copy(newPos);
    s.mesh.visible = true;

    // Update heading
    const dv = new THREE.Vector3().subVectors(newPos, prevPos);
    if (dv.length() > 0.001) s.heading.copy(dv.normalize());
    s.mesh.rotation.y = Math.atan2(s.heading.x, s.heading.z);

    // Wake trail
    updateWakeTrail(s, dt);
    renderWakeTrail(s);

    // Lock ring
    const inApproach = computeApproachRadius(player.pos, s);
    const targetRingOpacity = inApproach ? 0.8 : 0;
    s.lockRingOpacity = THREE.MathUtils.lerp(s.lockRingOpacity || 0, targetRingOpacity, 0.1);
    if (s.lockRing) {
      s.lockRing.position.copy(s.mesh.position);
      s.lockRing.position.y = 0.2;
      s.lockRing.material.opacity = s.lockRingOpacity;
      s.lockRing.rotation.y += 0.785 * dt; // 45 deg/s
    }

    // Ghost shimmer
    if (s.isGhost && s.shimmerTimer > 0) {
      s.shimmerTimer -= dt;
      const flicker = Math.sin(Date.now() * 0.001 * 12 * Math.PI) > 0 ? 1 : 0;
      // Brighten the mesh
      s.mesh.children.forEach(c => {
        if (c.material) c.material.emissiveIntensity = flicker * 1.5;
      });
    }
  });

  // Formation split timer
  if (ghostPacerSplitActive) {
    ghostPacerSplitTimer -= dt;
    if (ghostPacerSplitTimer <= 0) {
      ghostPacerSplitActive = false;
      ghostCopies.forEach(c => {
        c.mesh.visible = false;
        c.isCopy = false;
      });
    }
  }

  // ── PARTICLES ──
  particles.forEach(p => {
    p.age += dt;
    p.mesh.position.x += p.vx * dt;
    p.mesh.position.z += p.vz * dt;
    p.mat.opacity = Math.max(0, 1 - p.age / p.life);
  });
  particles = particles.filter(p => p.age < p.life);

  // Dissolve
  dissolveParts.forEach(p => {
    p.age += dt;
    p.mesh.position.x += p.vx * dt;
    p.mesh.position.y += p.vy * dt;
    p.mesh.position.z += p.vz * dt;
    p.mat.opacity = Math.max(0, 1 - p.age / p.life);
    p.mesh.rotation.x += dt * 3;
    p.mesh.rotation.z += dt * 2;
  });
  dissolveParts = dissolveParts.filter(p => p.age < p.life);

  // Speed bleed SFX
  if (audioReady && sfxSpeedBleed) {
    try {
      const shouldBleed = !player.isDrafting && player.speed > floorSpeedNow && player.speed < DRAFT_SPEED;
      if (shouldBleed && !sfxSpeedBleedActive) {
        sfxSpeedBleedActive = true;
        sfxSpeedBleed.triggerAttack(60);
      } else if (!shouldBleed && sfxSpeedBleedActive) {
        sfxSpeedBleedActive = false;
        sfxSpeedBleed.triggerRelease();
      }
    } catch(e) {}
  }

  // ── CAMERA ──
  camera.position.x = player.pos.x;
  camera.position.y = player.pos.y + 3.5;
  cameraZSmooth = THREE.MathUtils.lerp(cameraZSmooth, player.pos.z - 12, 0.33);
  camera.position.z = cameraZSmooth;
  camera.lookAt(player.pos.x, player.pos.y + 0.8, player.pos.z + 4);

  // Ocean follows player Z
  ocean.position.z = player.pos.z;
  gridHelper.position.z = player.pos.z;
  wallFlashMesh.position.z = player.pos.z;
}

// ──────────────────────────────────────────────────────────
// GAME LOOP
// ──────────────────────────────────────────────────────────
function loop(now) {
  requestAnimationFrame(loop);
  if (!lastTime) lastTime = now;
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  if (gameState === 'start') {
    updateStartScreen(dt);
  } else if (gameState === 'playing') {
    update(dt);
  }

  composer.render();
  drawHUD();
}

requestAnimationFrame(loop);

// ──────────────────────────────────────────────────────────
// SCREEN MANAGEMENT
// ──────────────────────────────────────────────────────────
function showScreen(name) {
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('instrScreen').classList.add('hidden');
  document.getElementById('endScreen').classList.add('hidden');
  const screenMap = { 'start': 'startScreen', 'instructions': 'instrScreen', 'results': 'endScreen' };
  if (name) document.getElementById(screenMap[name] || name).classList.remove('hidden');
}

function startInstructions() {
  initAudio();
  gameState = 'instructions';
  showScreen('instructions');
}

function startGame() {
  gameState = 'playing';
  showScreen(null);
  formationSplitFired = false;

  // Clean up start screen ships
  startShips.forEach(s => {
    scene.remove(s.mesh);
    s.wakePoints = [];
    if (s.wakeLineMesh) scene.remove(s.wakeLineMesh);
  });
  startShips = [];

  setupLevel(currentLevel);
  cameraZSmooth = player.pos.z - 12;
}

function endGame(won) {
  gameState = 'results';
  showScreen('results');

  const title = document.getElementById('endTitle');
  const stats = document.getElementById('endStats');

  if (won) {
    title.textContent = 'CIRCUIT COMPLETE';
    title.style.color = '#E8C84A';
  } else {
    title.textContent = 'SIGNAL LOST';
    title.style.color = '#FF4D1C';
  }

  stats.innerHTML = `
    Laps Completed: <span>${player.lap}</span><br>
    Best Chain: <span>×${player.bestChain}</span><br>
    Peak Speed: <span>${Math.round(player.bestSpeed)} u/s</span><br>
    Level: <span>${LEVELS[currentLevel].name}</span>
  `;
}

// ── EVENT HANDLERS ──
document.getElementById('startScreen').addEventListener('pointerdown', () => {
  if (gameState === 'start') startInstructions();
});

document.getElementById('instr-go').addEventListener('pointerdown', e => {
  e.stopPropagation();
  startGame();
});

document.getElementById('instrScreen').addEventListener('pointerdown', e => {
  if (e.target === document.getElementById('instr-go')) return;
  startGame();
});

document.getElementById('retry-btn').addEventListener('pointerdown', () => {
  formationSplitFired = false;
  ghostPacerSplitActive = false;
  ghostCopies = [];
  dissolveParts.forEach(p => scene.remove(p.mesh));
  dissolveParts = [];
  gameState = 'start';
  showScreen('start');
  buildStartScreen();
});

// Initialize start screen
buildStartScreen();

</script>
</body>
</html>
